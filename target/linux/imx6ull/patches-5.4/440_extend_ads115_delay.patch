Description: extending duration of delay
 This patch addresses 2 delays, influencing time of returninga latest
 stored in register value.
  1) instead 10% of { duration_previous + duration_latest } reworked to 20% of that time as extra await.
  this is required as was previously shown that second consequetial reading returns @proper@ value
  2) usleep_range now has changed upper range to make it more relaxed in firing interrupt
Author: IFG konara@ya.ru
Origin: upstream
Last-Update: 2023-01-09 
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
Index: linux-5.4.168/drivers/iio/adc/ti-ads1015.c
===================================================================
--- linux-5.4.168.orig/drivers/iio/adc/ti-ads1015.c
+++ linux-5.4.168/drivers/iio/adc/ti-ads1015.c
@@ -46,6 +46,7 @@
 #define ADS1015_CFG_MOD_SHIFT	8
 #define ADS1015_CFG_PGA_SHIFT	9
 #define ADS1015_CFG_MUX_SHIFT	12
+#define ADS1015_CFG_OS_SHIFT	15
 
 #define ADS1015_CFG_COMP_QUE_MASK	GENMASK(1, 0)
 #define ADS1015_CFG_COMP_LAT_MASK	BIT(2)
@@ -55,6 +56,7 @@
 #define ADS1015_CFG_MOD_MASK	BIT(8)
 #define ADS1015_CFG_PGA_MASK	GENMASK(11, 9)
 #define ADS1015_CFG_MUX_MASK	GENMASK(14, 12)
+#define ADS1015_CFG_OS_MASK BIT(15)
 
 /* Comparator queue and disable field */
 #define ADS1015_CFG_COMP_DISABLE	3
@@ -366,6 +368,8 @@ int ads1015_get_adc_result(struct ads101
 
 	cfg = (old & ~mask) | (cfg & mask);
 	if (old != cfg) {
+        cfg &= ~ADS1015_CFG_MOD_MASK;
+        cfg |= ADS1015_CFG_OS_MASK;
 		ret = regmap_write(data->regmap, ADS1015_CFG_REG, cfg);
 		if (ret)
 			return ret;
@@ -375,8 +379,9 @@ int ads1015_get_adc_result(struct ads101
 		dr_old = (old & ADS1015_CFG_DR_MASK) >> ADS1015_CFG_DR_SHIFT;
 		conv_time = DIV_ROUND_UP(USEC_PER_SEC, data->data_rate[dr_old]);
 		conv_time += DIV_ROUND_UP(USEC_PER_SEC, data->data_rate[dr]);
-		conv_time += conv_time / 10; /* 10% internal clock inaccuracy */
-		usleep_range(conv_time, conv_time + 1);
+		conv_time += conv_time / 10; /* 50% internal clock inaccuracy */
+		conv_time = DIV_ROUND_UP(conv_time, USEC_PER_MSEC);
+		msleep(conv_time);
 		data->conv_invalid = false;
 	}
 
